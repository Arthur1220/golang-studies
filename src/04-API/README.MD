# üèõÔ∏è API de Personalidades Hist√≥ricas

API RESTful desenvolvida em Go para gerenciar um cat√°logo de personalidades hist√≥ricas. O projeto demonstra a constru√ß√£o de um CRUD completo conectado a um banco de dados PostgreSQL, utilizando Docker para orquestra√ß√£o de ambiente.

## üöÄ Tecnologias e Bibliotecas

  * **[Gorilla Mux](https://github.com/gorilla/mux):** Roteador HTTP robusto e flex√≠vel.
  * **[GORM](https://gorm.io/):** ORM (Object Relational Mapper) para facilitar a intera√ß√£o com o banco de dados.
  * **[PostgreSQL](https://www.postgresql.org/):** Banco de dados relacional.
  * **Docker & Docker Compose:** Para subir o banco e o pgAdmin automaticamente.

## ‚öôÔ∏è Como Executar o Projeto

### 1\. Pr√©-requisitos

Certifique-se de ter o [Docker](https://www.docker.com/) e o [Go](https://go.dev/) instalados.

### 2\. Subindo o Banco de Dados

O projeto utiliza um arquivo `docker-compose.yml` que sobe o PostgreSQL e j√° cria a tabela e insere dados iniciais (via script de migra√ß√£o).

```bash
# Na raiz do projeto, execute:
docker-compose up -d
```

*Isso iniciar√° o Postgres na porta `5432` e o pgAdmin na porta `54321`.*

### 3\. Rodando a API

```bash
# Baixe as depend√™ncias
go mod tidy

# Execute o servidor
go run main.go
```

O servidor iniciar√° em: **http://localhost:8000**

-----

## üîó Endpoints da API

| M√©todo | Rota | Descri√ß√£o |
| :--- | :--- | :--- |
| `GET` | `/api/personalidades` | Retorna todas as personalidades (JSON) |
| `GET` | `/api/personalidades/{id}` | Retorna uma personalidade espec√≠fica pelo ID |
| `POST` | `/api/personalidades` | Cria uma nova personalidade |
| `PUT` | `/api/personalidades/{id}` | Edita/Atualiza uma personalidade existente |
| `DELETE` | `/api/personalidades/{id}` | Remove uma personalidade do banco |

-----

## üß† An√°lise T√©cnica e Destaques do C√≥digo

Abaixo, detalho as decis√µes arquiteturais e trechos importantes do c√≥digo.

### 1\. ORM e Abstra√ß√£o do Banco (`database/db.go`)

Utilizamos o **GORM** para n√£o precisarmos escrever SQL puro manualmente. Note como a conex√£o √© simples:

```go
// A string de conex√£o define o host, usu√°rio, senha e banco (configurados no Docker)
stringDB := "host=localhost user=root password=root dbname=root port=5432 sslmode=disable"
DB, err = gorm.Open(postgres.Open(stringDB))
```

### 2\. Controllers e JSON (`controllers/controllers.go`)

O Go trata JSON nativamente. Nos controllers, fazemos o processo de **Encoding** (Go -\> JSON) e **Decoding** (JSON -\> Go).

**Exemplo: Criando um registro (POST)**

```go
func CriarPersonalidade(w http.ResponseWriter, r *http.Request) {
    var personalidade models.Personalidade
    
    // 1. Decoder: Pega o JSON que veio no corpo da requisi√ß√£o (Body) e converte para a Struct
    json.NewDecoder(r.Body).Decode(&personalidade)
    
    // 2. GORM: O m√©todo .Create insere no banco automaticamente
    database.DB.Create(&personalidade)
    
    // 3. Encoder: Devolve o objeto criado como JSON para o cliente
    json.NewEncoder(w).Encode(personalidade)
}
```

**Exemplo: Buscando por ID (GET)**
O `Gorilla Mux` facilita a extra√ß√£o de vari√°veis da URL:

```go
vars := mux.Vars(r) // Pega todas as vari√°veis da rota
id := vars["id"]    // Extrai o ID da URL /api/personalidades/{id}

database.DB.First(&personalidade, id) // O GORM busca automaticamente pelo Primary Key
```

### 3\. Middleware (`middleware/middleware.go`)

Middlewares s√£o fun√ß√µes que interceptam a requisi√ß√£o antes dela chegar no Controller. Criamos um middleware para garantir que **todas** as respostas da API tenham o cabe√ßalho `Content-Type: application/json`.

```go
func ContentTypeMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json") // Define JSON
        next.ServeHTTP(w, r) // Passa para o pr√≥ximo passo (o Controller)
    })
}
```

### 4\. Roteamento (`routes/routes.go`)

Aqui amarramos tudo. Definimos as rotas, os verbos HTTP permitidos e injetamos o Middleware.

```go
r := mux.NewRouter()
r.Use(middleware.ContentTypeMiddleware) // Aplica o middleware globalmente

// Definimos explicitamente qual verbo HTTP cada fun√ß√£o aceita
r.HandleFunc("/api/personalidades", controllers.CriarPersonalidade).Methods("POST")
```

-----

## üê≥ Docker e Migra√ß√£o Autom√°tica

O arquivo `migration/docker-database-initial.sql` √© montado dentro do container do Postgres. Quando o container nasce pela primeira vez, o Postgres executa esse script automaticamente:

```sql
create table personalidades( ... );
INSERT INTO personalidades ...;
```

Isso garante que qualquer pessoa que baixe seu projeto tenha o banco pronto para uso sem precisar criar tabelas manualmente.

-----

Desenvolvido com Go üêπ