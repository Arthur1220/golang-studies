# üìò Fundamentos e Setup

Guia de instala√ß√£o, configura√ß√£o de ambiente e sintaxe base da linguagem Go.

---

## üõ†Ô∏è Instala√ß√£o e Configura√ß√£o (WSL/Linux)

Passo a passo para instalar a vers√£o mais recente do Go no Linux (Ubuntu/WSL).

### 1\. Limpeza e Download

```bash
# Remove instala√ß√µes anteriores para evitar conflitos
sudo rm -rf /usr/local/go

# Baixa a vers√£o est√°vel (Verifique a vers√£o atual em go.dev/dl)
wget https://go.dev/dl/go1.23.4.linux-amd64.tar.gz

# Extrai para o diret√≥rio padr√£o
sudo tar -C /usr/local -xzf go1.23.4.linux-amd64.tar.gz
```

### 2\. Configura√ß√£o do PATH

Dependendo do seu terminal (`bash` ou `zsh`), execute os comandos abaixo para que o sistema encontre o comando `go`.

**Para Bash:**

```bash
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.bashrc
echo 'export PATH=$PATH:$(go env GOPATH)/bin' >> ~/.bashrc
source ~/.bashrc
```

**Para Zsh (Padr√£o em muitos setups modernos):**

```zsh
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.zshrc
echo 'export PATH=$PATH:$(go env GOPATH)/bin' >> ~/.zshrc
source ~/.zshrc
```

### 3\. Verifica√ß√£o e Inicializa√ß√£o

```bash
# Verifica se instalou corretamente
go version

# Inicializa o gerenciador de depend√™ncias (cria o arquivo go.mod)
go mod init nome-do-projeto
```

-----

## üìÇ Estrutura e Compila√ß√£o

### Organiza√ß√£o de Pastas (Conven√ß√£o Cl√°ssica)

Embora o Go Modules tenha flexibilizado isso, a estrutura cl√°ssica √©:

  * `bin/`: Bin√°rios compilados (execut√°veis).
  * `pkg/`: Objetos de pacotes compilados (bibliotecas).
  * `src/`: C√≥digo fonte (`.go`).

### O Arquivo Principal

Todo programa execut√°vel em Go deve come√ßar definindo o pacote como `main`. √â similar √† fun√ß√£o `main` do C: o ponto de entrada.

```go
package main

import "fmt" // Pacote para I/O (Input/Output) formatado

func main() {
    // C√≥digo aqui
}
```

### Rodando o C√≥digo

Go √© uma linguagem compilada (como C), mas pode ser rodada diretamente para testes.

  * **Compilar e Executar (R√°pido):** `go run arquivo.go`
  * **Apenas Compilar (Gera execut√°vel):** `go build arquivo.go`
  * **Executar bin√°rio:** `./arquivo`

-----

## üìù Sintaxe B√°sica e Vari√°veis

### Declara√ß√£o de Vari√°veis

Go √© fortemente tipado, mas possui infer√™ncia de tipo (parecido com Python, mas est√°tico).

```go
// 1. Declara√ß√£o expl√≠cita (Estilo C)
var nome string = "Jo√£o"

// 2. Infer√™ncia de tipo (O compilador descobre)
var idade = 30

// 3. Short Syntax (A mais usada dentro de fun√ß√µes)
email := "joao@email.com" 
```

> **Regra Importante:** O Go n√£o compila se houver vari√°veis declaradas e n√£o utilizadas (evita lixo no c√≥digo).

### Zero-Initialization (Valores Padr√£o)

Em Go, vari√°veis n√£o inicializadas **n√£o** cont√™m lixo de mem√≥ria. Elas come√ßam com valores "Zero":

| Tipo | Valor Zero |
| :--- | :--- |
| `int`, `float` | `0` |
| `string` | `""` (vazio) |
| `bool` | `false` |
| `pointer`, `interface`, `slice` | `nil` |
| `struct` | `{}` (campos zerados) |

### Tipos Primitivos Comuns

  * `string`
  * `int`, `int8`, `int64`
  * `float32`, `float64`
  * `bool`

### Constantes

Valores imut√°veis, definidos em tempo de compila√ß√£o.

```go
const Pi = 3.14
const Status = "Ativo"
```

-----

## üñ®Ô∏è Output e Input

### Sa√≠da (Output)

  * `fmt.Print`: Imprime sem pular linha.
  * `fmt.Println`: Imprime e pula linha no final.
  * `fmt.Printf`: Imprime formatado.

**Formatadores do Printf:**

  * `%s`: String
  * `%d`: Inteiro (Decimal)
  * `%f`: Float (`%.2f` para 2 casas decimais)
  * `%v`: Valor gen√©rico (serve para qualquer coisa)
  * `%T`: Mostra o Tipo da vari√°vel

### Entrada (Input)

```go
var comando int
// O & indica o endere√ßo de mem√≥ria onde o valor ser√° salvo.
fmt.Scan(&comando)
```

-----

## üîÄ Controle de Fluxo

### IF / ELSE

Sem par√™nteses na condi√ß√£o, chaves `{}` obrigat√≥rias.

```go
if idade >= 18 {
    fmt.Println("Maior de idade")
} else {
    fmt.Println("Menor de idade")
}
```

### Switch

N√£o precisa de `break` (autom√°tico).

```go
switch comando {
    case 1:
        fmt.Println("Monitorando...")
    default:
        fmt.Println("Comando desconhecido")
}
```

### Loops (For)

Go **n√£o** tem `while`. O `for` faz tudo.

```go
// 1. Loop Infinito (While true)
for { }

// 2. Loop Cl√°ssico (C Style)
for i := 0; i < 10; i++ { }

// 3. Range (Python Style)
nomes := []string{"Ana", "Jose"}
for i, nome := range nomes {
    fmt.Println(i, nome)
}
```

-----

## üì¶ Arrays e Slices

### Arrays

Tamanho fixo. Pouco usado.

```go
var sites [4]string
```

### Slices

Tamanho din√¢mico. Muito usado.

```go
nomes := []string{"Douglas", "Daniel"}
nomes = append(nomes, "Novo Nome")

len(nomes) // Tamanho atual
cap(nomes) // Capacidade total alocada
```

> Quando a capacidade estoura, o Go dobra o tamanho do array interno automaticamente.

-----

## ‚öôÔ∏è Funcionalidades de Sistema e Web

### Time / Sleep

Podemos pausar a execu√ß√£o da *goroutine* atual utilizando a fun√ß√£o `Sleep` do pacote `time`.
Isso √© essencial em loops de monitoramento para n√£o sobrecarregar a CPU ou o servi√ßo que est√° sendo consultado, criando um intervalo saud√°vel entre as a√ß√µes.

```go
import "time"

// Pausa a execu√ß√£o por 5 segundos
// time.Second √© uma constante que representa 1 segundo
time.Sleep(5 * time.Second)
```

### Requisi√ß√µes Web (HTTP)

Para fazer chamadas a APIs ou sites externos, usamos o pacote nativo `net/http`.

```go
import ("net/http"; "fmt")

func testaSite(site string) {
    // O _ ignora o erro (n√£o recomendado em prod, mas ok para teste simples)
    resp, _ := http.Get(site)

    if resp.StatusCode == 200 {
        fmt.Println("Site carregado com sucesso!")
    }
}
```

### Sair e Limpar

```go
import ("os"; "os/exec")

// Sai do programa com c√≥digo de sucesso (0) ou erro (-1)
os.Exit(0) 

// Limpar Terminal (Linux/Mac)
func limpar() {
    c := exec.Command("clear")
    c.Stdout = os.Stdout
    c.Run()
}
```

### Defer

Adia a execu√ß√£o de uma fun√ß√£o at√© o momento que a fun√ß√£o pai terminar (return). √â perfeito para garantir o fechamento de recursos.

```go
func ler() {
    arquivo, _ := os.Open("dados.txt")
    defer arquivo.Close() // Ser√° executado por √∫ltimo, n√£o importa o que aconte√ßa
    // ... processamento ...
}
```

-----

## üìÑ Arquivos (Files)

Para ler e escrever arquivos, usamos os pacotes `os` (opera√ß√µes de sistema) e `io` ou `bufio` (leitura).

### Lendo um arquivo inteiro

```go
import ("os"; "fmt")

func lerArquivo() {
    // Retorna um array de bytes (conte√∫do) e um erro
    arquivo, err := os.ReadFile("log.txt") 
    
    if err != nil {
        fmt.Println("Erro ao ler:", err)
    }
    
    // Converte bytes para string
    fmt.Println(string(arquivo)) 
}
```

### Escrevendo em um arquivo

```go
func escreverLog() {
    // Abre o arquivo. Flags: Criar se n√£o existir, Escrita, Append (adicionar no final)
    // 0666 √© a permiss√£o do arquivo no Linux (Leitura/Escrita)
    arquivo, _ := os.OpenFile("log.txt", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
    
    defer arquivo.Close() // Garante o fechamento do arquivo
    
    arquivo.WriteString("Log de erro registrado\n")
}
```
