# üç∏ API de Estudantes com Gin & GORM

Bem-vindo √† evolu√ß√£o do desenvolvimento web em Go. Este projeto implementa uma API REST completa para gerenciamento de estudantes, utilizando o framework **Gin** (para rotas e HTTP) e **GORM** (para banco de dados).

O objetivo principal deste m√≥dulo √© demonstrar o ganho de **produtividade** e **performance** ao sair do roteamento manual (`net/http` + `Gorilla Mux`) para um Framework Web moderno.

-----

## üÜö O Poder do Gin: Comparativo

A principal diferen√ßa que voc√™ notar√° √© a redu√ß√£o de c√≥digo boilerplate (c√≥digo repetitivo). Veja a compara√ß√£o:

### 1\. Retornando JSON

**Sem Gin (net/http):**

```go
// Voc√™ precisava configurar o header e criar um Encoder manualmente
w.Header().Set("Content-Type", "application/json")
json.NewEncoder(w).Encode(aluno)
```

**Com Gin:**

```go
// O Gin j√° sabe que √© JSON, configura o header e serializa tudo em uma linha
c.JSON(200, aluno)
```

### 2\. Lendo o Corpo da Requisi√ß√£o (Body)

**Sem Gin:**

```go
var aluno Aluno
// Precisava criar um Decoder e tratar erros manualmente
err := json.NewDecoder(r.Body).Decode(&aluno)
if err != nil {
    w.WriteHeader(http.StatusBadRequest)
    return
}
```

**Com Gin (Magic Binding):**

```go
var aluno Aluno
// ShouldBindJSON faz o decode E valida os campos automaticamente
if err := c.ShouldBindJSON(&aluno); err != nil {
    c.JSON(400, gin.H{"error": err.Error()})
    return
}
```

### 3\. Pegando Par√¢metros da URL

**Sem Gin (Gorilla Mux):**

```go
vars := mux.Vars(r)
id := vars["id"]
```

**Com Gin:**

```go
id := c.Param("id") // Simples e direto
```

-----

## üöÄ Como Executar

### 1\. Subindo o Banco (Docker)

Este projeto usa PostgreSQL vers√£o 16.

```bash
docker-compose up -d
```

### 2\. Rodando a API

```bash
go mod tidy
go run main.go
```

O servidor iniciar√° em **http://localhost:8080** (Padr√£o do Gin, diferente do 8000 anterior).

-----

## üîó Endpoints Dispon√≠veis

| Verbo | Rota | Descri√ß√£o |
| :--- | :--- | :--- |
| `GET` | `/` | Retorna mensagem de boas vindas |
| `GET` | `/introduce/:name` | Exemplo de uso de par√¢metros na URL |
| `GET` | `/students` | Lista todos os estudantes |
| `POST` | `/students` | Cria um novo estudante (JSON Body) |
| `GET` | `/students/:id` | Busca estudante por ID |
| `DELETE` | `/students/:id` | Deleta estudante por ID |
| `PUT` | `/students/:id` | Atualiza dados do estudante |
| `GET` | `/students/name/:name` | Busca estudante pelo nome (Busca exata) |

-----

## üß† Detalhes da Implementa√ß√£o

### Estrutura MVC Simplificada

  * **`routes/routes.go`**: Onde definimos os endpoints. Note o uso de `gin.Default()`, que j√° cria um roteador com **Logger** (logs coloridos no terminal) e **Recovery** (se der panic, a API n√£o cai, ela retorna 500).
  * **`controllers/controllers.go`**: A l√≥gica das rotas.
  * **`models/student.go`**: Defini√ß√£o da tabela do banco.
  * **`database/db.go`**: Conex√£o com GORM.

### O Contexto do Gin (`*gin.Context`)

Diferente do Go puro que passa `w` (Writer) e `r` (Request) separados, o Gin encapsula tudo no **Contexto (`c`)**.

  * √â atrav√©s do `c` que voc√™ pega dados (`c.Param`, `c.Query`, `c.ShouldBindJSON`).
  * √â atrav√©s do `c` que voc√™ responde (`c.JSON`, `c.String`, `c.HTML`).

### GORM: Auto Migration

No arquivo `database/db.go`, utilizamos:

```go
DB.AutoMigrate(&models.Student{})
```

Isso significa que voc√™ **n√£o precisa criar tabela SQL na m√£o**. O GORM olha para a sua Struct `Student` e cria (ou atualiza) a tabela no Postgres automaticamente quando o servidor sobe.

### Tratamento de Erros

O Gin facilita retornar erros amig√°veis. Usamos muito o `gin.H{}` que √© um atalho para `map[string]interface{}`.

```go
c.JSON(404, gin.H{
    "error": "Student not found",
})
```

-----

Desenvolvido com üíú e Go.