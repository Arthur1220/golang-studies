# üèóÔ∏è Orienta√ß√£o a Objetos e Estruturas

Como Go implementa conceitos de POO utilizando Structs, Interfaces e Composi√ß√£o.

---

## Structs

Go n√£o tem classes. Go tem **Structs**.
√â uma cole√ß√£o de campos. Funciona como o `struct` de C ou objetos literais de JS.

```go
type ContaCorrente struct {
    Titular       string
    NumeroAgencia int
    NumeroConta   int
    Saldo         float64
}

// Instanciando
conta := ContaCorrente{
    Titular:       "Jo√£o Silva",
    NumeroAgencia: 1234,
    Saldo:         1500.75, // Campos omitidos ficam com Valor Zero
}

// Acessando
fmt.Println(conta.Titular)
```

### Ponteiros e Aloca√ß√£o (`new` vs `&`)

Ponteiros armazenam o **endere√ßo de mem√≥ria** de um valor, n√£o o valor em si. Isso economiza mem√≥ria (evita c√≥pias de objetos grandes) e permite alterar o valor original.

**1. Usando `&` (Mais comum):**
Cria a estrutura e retorna o endere√ßo dela.

```go
var conta *ContaCorrente
conta = &ContaCorrente{Titular: "Maria"} 
```

**2. Usando `new`:**
Aloca mem√≥ria zerada e retorna o ponteiro. Pouco usado em estruturas complexas pois n√£o permite inicializar campos na hora.

```go
conta2 := new(ContaCorrente) // Retorna *ContaCorrente
conta2.Titular = "Jos√©"
```

-----

## ‚ö° M√©todos e Fun√ß√µes

### Fun√ß√µes Vari√°dicas

Fun√ß√µes que aceitam um n√∫mero indeterminado de argumentos (usando `...`).

```go
func Somando(numeros ...int) int {
    soma := 0
    for _, num := range numeros {
        soma += num
    }
    return soma
}
// Uso: Somando(1, 2, 3, 4, 5)
```

### M√©todos vs. Fun√ß√µes (Receivers)

Em Go, podemos "anexar" uma fun√ß√£o a uma Struct. Isso √© o equivalente a **M√©todos** em outras linguagens.

**1. Fun√ß√£o Tradicional (Style C):**
Recebe a struct como par√¢metro. N√£o faz parte do objeto.

```go
func sacar(conta *ContaCorrente, valor float64) { ... }
// Uso: sacar(&conta, 200)
```

**2. M√©todo com Receiver (Style Go/POO):**
A fun√ß√£o "pertence" √† struct. O `(c *ContaCorrente)` antes do nome da fun√ß√£o √© o **Receiver**.

```go
func (c *ContaCorrente) Sacar(valor float64) string {
    if c.Saldo >= valor {
        c.Saldo -= valor
        return "Sucesso"
    }
    return "Saldo Insuficiente"
}
// Uso: conta.Sacar(200)
```

> **Dica:** Use **Pointer Receiver** (`*ContaCorrente`) se voc√™ precisa alterar o valor da struct original. Se usar Value Receiver (`ContaCorrente`), voc√™ estar√° mexendo em uma c√≥pia.

-----

## üì¶ Pacotes e Visibilidade

Para organizar o c√≥digo, dividimos em pastas (pacotes).

### Comandos Essenciais

  * `go mod init <nome>`: Cria o m√≥dulo inicial.
  * `go mod tidy`: Baixa depend√™ncias que faltam e remove as que n√£o s√£o usadas (limpeza).
  * `go build ./...`: Compila todos os pacotes dentro da pasta para verificar erros.

### Encapsulamento (Public vs Private)

Go n√£o tem `public` ou `private`. A visibilidade √© definida pela **Letra Inicial**.

  * **Mai√∫scula (ex: `Sacar`)**: **P√∫blico (Exported)**. Vis√≠vel para outros pacotes.
  * **Min√∫scula (ex: `saldo`)**: **Privado (Unexported)**. Vis√≠vel apenas dentro do pacote onde foi criado.

**Exemplo de Encapsulamento (Getters/Setters):**

```go
package contas

type Conta struct {
    Titular string  // P√∫blico
    saldo   float64 // Privado (ningu√©m mexe direto)
}

// M√©todo P√∫blico para ler o saldo privado
func (c *Conta) ObterSaldo() float64 {
    return c.saldo
}
```

-----

## üîÅ Interfaces (Polimorfismo)

Interfaces em Go definem **comportamento**. Se uma struct tem os m√©todos que a interface pede, ela implementa a interface automaticamente (Duck Typing). N√£o existe `implements`.

```go
// Contrato: "Qualquer coisa que tenha o m√©todo VerificarConta √© um Verificavel"
type Verificavel interface {
    VerificarConta() bool
}

func (c ContaCorrente) VerificarConta() bool {
    return true
}

// Esta fun√ß√£o aceita QUALQUER coisa que respeite a interface Verificavel
func RealizarVerificacao(v Verificavel) {
    v.VerificarConta()
}
```