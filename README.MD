# üìò Guia de Estudos e Setup: Go (Golang)

![Go Version](https://img.shields.io/badge/Go-1.25.4-blue) ![Status](https://img.shields.io/badge/Status-Learning-green)

Espa√ßo destinado aos meus estudos e experimentos com **Go**.
Este reposit√≥rio serve como um guia pessoal de consulta e portf√≥lio de evolu√ß√£o na linguagem.

### üìö Recursos Oficiais
Para quem tamb√©m est√° estudando, recomendo:
- [Documenta√ß√£o Oficial](https://go.dev/doc/)
- [Go by Example](https://gobyexample.com/)
- [Go Playground](https://go.dev/play/)


-----

## üõ†Ô∏è Instala√ß√£o e Configura√ß√£o (WSL/Linux)

Passo a passo para instalar a vers√£o mais recente do Go no Linux (Ubuntu/WSL).

### 1\. Limpeza e Download

```bash
# Remove instala√ß√µes anteriores para evitar conflitos
sudo rm -rf /usr/local/go

# Baixa a vers√£o est√°vel (Verifique a vers√£o atual em go.dev/dl)
wget https://go.dev/dl/go1.23.4.linux-amd64.tar.gz

# Extrai para o diret√≥rio padr√£o
sudo tar -C /usr/local -xzf go1.23.4.linux-amd64.tar.gz
```

### 2\. Configura√ß√£o do PATH

Dependendo do seu terminal (`bash` ou `zsh`), execute os comandos abaixo para que o sistema encontre o comando `go`.

**Para Bash:**

```bash
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.bashrc
echo 'export PATH=$PATH:$(go env GOPATH)/bin' >> ~/.bashrc
source ~/.bashrc
```

**Para Zsh (Padr√£o em muitos setups modernos):**

```zsh
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.zshrc
echo 'export PATH=$PATH:$(go env GOPATH)/bin' >> ~/.zshrc
source ~/.zshrc
```

### 3\. Verifica√ß√£o e Inicializa√ß√£o

```bash
# Verifica se instalou corretamente
go version

# Inicializa o gerenciador de depend√™ncias (cria o arquivo go.mod)
go mod init nome-do-projeto
```

-----

## üìÇ Estrutura e Compila√ß√£o

### Organiza√ß√£o de Pastas (Conven√ß√£o Cl√°ssica)

Embora o Go Modules tenha flexibilizado isso, a estrutura cl√°ssica √©:

  * `bin/`: Bin√°rios compilados (execut√°veis).
  * `pkg/`: Objetos de pacotes compilados (bibliotecas).
  * `src/`: C√≥digo fonte (`.go`).

### O Arquivo Principal

Todo programa execut√°vel em Go deve come√ßar definindo o pacote como `main`. √â similar √† fun√ß√£o `main` do C: o ponto de entrada.

```go
package main

import "fmt" // Pacote para I/O (Input/Output) formatado

func main() {
    // C√≥digo aqui
}
```

### Rodando o C√≥digo

Go √© uma linguagem compilada (como C), mas pode ser rodada diretamente para testes.

  * **Compilar e Executar (R√°pido):** `go run arquivo.go`
  * **Apenas Compilar (Gera execut√°vel):** `go build arquivo.go`
  * **Executar bin√°rio:** `./arquivo`

-----

## üìù Sintaxe B√°sica e Vari√°veis

### Declara√ß√£o de Vari√°veis

Go √© fortemente tipado, mas possui infer√™ncia de tipo (parecido com Python, mas est√°tico).

```go
// 1. Declara√ß√£o expl√≠cita (Estilo C)
var nome string = "Jo√£o"

// 2. Infer√™ncia de tipo (O compilador descobre)
var idade = 30

// 3. Short Syntax (A mais usada dentro de fun√ß√µes)
email := "joao@email.com" 
```

> **Regra Importante:** O Go n√£o compila se houver vari√°veis declaradas e n√£o utilizadas (evita lixo no c√≥digo).
> **Valor Zero:** Se n√£o atribuir valor, Go define um padr√£o: `0` para n√∫meros, `""` (vazio) para strings, `false` para booleanos.

### Descobrindo o Tipo

```go
import "reflect"
// ...
fmt.Println(reflect.TypeOf(nome_da_variavel))
```

### Tipos Primitivos Comuns

  * `string`
  * `int`, `int8`, `int64`
  * `float32`, `float64`
  * `bool`

### Constantes

Valores imut√°veis, definidos em tempo de compila√ß√£o.

```go
const Pi = 3.14
const Status = "Ativo"
```

-----

## üñ®Ô∏è Output e Input (Prints e Scans)

O pacote `fmt` √© o padr√£o.

### Sa√≠da (Output)

  * `fmt.Print`: Imprime sem pular linha.
  * `fmt.Println`: Imprime e pula linha no final.
  * `fmt.Printf`: Imprime formatado (igual ao C).

**Formatadores do Printf:**

  * `%s`: String
  * `%d`: Inteiro (Decimal)
  * `%f`: Float (`%.2f` para 2 casas decimais)
  * `%v`: Valor gen√©rico (serve para qualquer coisa, muito √∫til)
  * `%T`: Mostra o Tipo da vari√°vel

### Entrada (Input)

```go
var comando int

// Op√ß√£o 1: Scanf (Estilo C - precisa formatador)
fmt.Scanf("%d", &comando) 

// Op√ß√£o 2: Scan (Mais inteligente - infere o tipo)
fmt.Scan(&comando)
```

> O `&` √© o ponteiro, indicando o endere√ßo de mem√≥ria onde o valor ser√° salvo.

-----

## üîÄ Controle de Fluxo

### IF / ELSE

N√£o usa par√™nteses na condi√ß√£o, mas as chaves `{}` s√£o obrigat√≥rias.

```go
if idade >= 18 {
    fmt.Println("Maior de idade")
} else {
    fmt.Println("Menor de idade")
}
```

### Switch

N√£o precisa de `break` (ele sai automaticamente ap√≥s executar o case, diferente de C que executaria os pr√≥ximos se n√£o parasse).

```go
switch comando {
    case 1:
        fmt.Println("Monitorando...")
    case 0:
        fmt.Println("Saindo...")
    default:
        fmt.Println("Comando desconhecido")
}
```

### Loops (For)

Go **n√£o** tem `while`. O `for` faz tudo.

```go
// 1. Loop Infinito (Substituto do while(true))
for {
    // Roda para sempre at√© um break
}

// 2. Loop Cl√°ssico (Estilo C)
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// 3. Range (Estilo Python enumerate)
nomes := []string{"Ana", "Jose"}
for i, nome := range nomes {
    fmt.Println(i, nome)
}
// Se n√£o precisar do √≠ndice, use o Blank Identifier (_)
for _, nome := range nomes {
    fmt.Println(nome)
}
```

-----

## üì¶ Arrays e Slices (Listas)

### Arrays

Tamanho fixo. Pouco usado na pr√°tica, pois √© r√≠gido (igual C).

```go
var sites [4]string
sites[0] = "google.com"
```

### Slices

Tamanho din√¢mico (abstra√ß√£o em cima do array). Muito usado (parecido com listas Python).

```go
// Declara√ß√£o
nomes := []string{"Douglas", "Daniel"}

// Adicionando elementos (Fun√ß√£o append)
nomes = append(nomes, "Novo Nome")

// Propriedades
len(nomes) // Tamanho atual (Length)
cap(nomes) // Capacidade do array subjacente
```

> Quando a capacidade estoura, o Go automaticamente dobra o tamanho do array interno.

-----

## üß© Fun√ß√µes

Sintaxe: `func nome(parametros) retorno`.
Go permite **m√∫ltiplos retornos**, uma caracter√≠stica poderosa.

```go
// Fun√ß√£o que retorna duas informa√ß√µes
func devolverNomeEIdade() (string, int) {
    return "Arthur", 25
}

func main() {
    // Recebendo os dois valores
    nome, idade := devolverNomeEIdade()
    
    // Ignorando um valor com _
    _, idadeSozinha := devolverNomeEIdade()
}
```

-----

## ‚öôÔ∏è Funcionalidades de Sistema e Web

### Sair do Programa

```go
import "os"

os.Exit(0)  // Sucesso
os.Exit(-1) // Erro
```

### Limpar o Terminal

Go n√£o tem comando nativo direto como `system("cls")` simples, depende do SO. A forma correta usando o pacote `os/exec`:

```go
import ("os"; "os/exec")

func limparTerminal() {
    c := exec.Command("clear") // Use "cls" se estiver rodando no CMD do Windows nativo
    c.Stdout = os.Stdout
    c.Run()
}
```

### Requisi√ß√µes Web (HTTP)

```go
import "net/http"

func testaSite(site string) {
    // O _ ignora o erro (n√£o recomendado em prod, mas ok para teste simples)
    resp, _ := http.Get(site)

    if resp.StatusCode == 200 {
        fmt.Println("Site carregado!")
    }
}
```

### O que √© `defer`?

O `defer` adia a execu√ß√£o de uma fun√ß√£o at√© o momento que a fun√ß√£o atual terminar (return). √â perfeito para limpeza de recursos.

```go
func lerSite() {
    resp, _ := http.Get("http://google.com")
    
    // Assim que a fun√ß√£o lerSite acabar, feche a conex√£o.
    // Isso garante que n√£o vamos esquecer a conex√£o aberta, mesmo se der erro no meio.
    defer resp.Body.Close() 
    
    // ... c√≥digo de leitura ...
}
```

### Time / Sleep

```go
import "time"

// Pausa a execu√ß√£o por 5 segundos
time.Sleep(5 * time.Second)
```

-----

## üìÑ Arquivos (Files)

Para ler e escrever arquivos, usamos os pacotes `os` (opera√ß√µes de sistema) e `io` ou `bufio` (leitura).

### Lendo um arquivo inteiro

```go
import ("os"; "fmt")

func lerArquivo() {
    // Retorna um array de bytes (conte√∫do) e um erro
    arquivo, err := os.ReadFile("log.txt") 
    
    if err != nil {
        fmt.Println("Erro ao ler:", err)
    }
    
    // Converte bytes para string
    fmt.Println(string(arquivo)) 
}
```

### Escrevendo em um arquivo

```go
func escreverLog() {
    // Abre o arquivo. Flags: Criar se n√£o existir, Escrita, Append (adicionar no final)
    arquivo, _ := os.OpenFile("log.txt", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
    
    defer arquivo.Close() // Garante o fechamento do arquivo
    
    arquivo.WriteString("Log de erro registrado\n")
}
```