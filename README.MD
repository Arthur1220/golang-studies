# üìò Guia de Estudos e Setup: Go (Golang)

![Go Version](https://img.shields.io/badge/Go-1.25.4-blue) ![Status](https://img.shields.io/badge/Status-Learning-green)

Espa√ßo destinado aos meus estudos e experimentos com **Go**.
Este reposit√≥rio serve como um guia pessoal de consulta e portf√≥lio de evolu√ß√£o na linguagem.

### üìö Recursos Oficiais

Para quem tamb√©m est√° estudando, recomendo:

  - [Documenta√ß√£o Oficial](https://go.dev/doc/)
  - [Go by Example](https://gobyexample.com/)
  - [Go Playground](https://go.dev/play/)

-----

## üõ†Ô∏è Instala√ß√£o e Configura√ß√£o (WSL/Linux)

Passo a passo para instalar a vers√£o mais recente do Go no Linux (Ubuntu/WSL).

### 1\. Limpeza e Download

```bash
# Remove instala√ß√µes anteriores para evitar conflitos
sudo rm -rf /usr/local/go

# Baixa a vers√£o est√°vel (Verifique a vers√£o atual em go.dev/dl)
wget https://go.dev/dl/go1.23.4.linux-amd64.tar.gz

# Extrai para o diret√≥rio padr√£o
sudo tar -C /usr/local -xzf go1.23.4.linux-amd64.tar.gz
```

### 2\. Configura√ß√£o do PATH

Dependendo do seu terminal (`bash` ou `zsh`), execute os comandos abaixo para que o sistema encontre o comando `go`.

**Para Bash:**

```bash
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.bashrc
echo 'export PATH=$PATH:$(go env GOPATH)/bin' >> ~/.bashrc
source ~/.bashrc
```

**Para Zsh (Padr√£o em muitos setups modernos):**

```zsh
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.zshrc
echo 'export PATH=$PATH:$(go env GOPATH)/bin' >> ~/.zshrc
source ~/.zshrc
```

### 3\. Verifica√ß√£o e Inicializa√ß√£o

```bash
# Verifica se instalou corretamente
go version

# Inicializa o gerenciador de depend√™ncias (cria o arquivo go.mod)
go mod init nome-do-projeto
```

-----

## üìÇ Estrutura e Compila√ß√£o

### Organiza√ß√£o de Pastas (Conven√ß√£o Cl√°ssica)

Embora o Go Modules tenha flexibilizado isso, a estrutura cl√°ssica √©:

  * `bin/`: Bin√°rios compilados (execut√°veis).
  * `pkg/`: Objetos de pacotes compilados (bibliotecas).
  * `src/`: C√≥digo fonte (`.go`).

### O Arquivo Principal

Todo programa execut√°vel em Go deve come√ßar definindo o pacote como `main`. √â similar √† fun√ß√£o `main` do C: o ponto de entrada.

```go
package main

import "fmt" // Pacote para I/O (Input/Output) formatado

func main() {
    // C√≥digo aqui
}
```

### Rodando o C√≥digo

Go √© uma linguagem compilada (como C), mas pode ser rodada diretamente para testes.

  * **Compilar e Executar (R√°pido):** `go run arquivo.go`
  * **Apenas Compilar (Gera execut√°vel):** `go build arquivo.go`
  * **Executar bin√°rio:** `./arquivo`

-----

## üìù Sintaxe B√°sica e Vari√°veis

### Declara√ß√£o de Vari√°veis

Go √© fortemente tipado, mas possui infer√™ncia de tipo (parecido com Python, mas est√°tico).

```go
// 1. Declara√ß√£o expl√≠cita (Estilo C)
var nome string = "Jo√£o"

// 2. Infer√™ncia de tipo (O compilador descobre)
var idade = 30

// 3. Short Syntax (A mais usada dentro de fun√ß√µes)
email := "joao@email.com" 
```

> **Regra Importante:** O Go n√£o compila se houver vari√°veis declaradas e n√£o utilizadas (evita lixo no c√≥digo).

### Zero-Initialization (Valores Padr√£o)

Em Go, vari√°veis n√£o inicializadas **n√£o** cont√™m lixo de mem√≥ria. Elas come√ßam com valores "Zero":

| Tipo | Valor Zero |
| :--- | :--- |
| `int`, `float` | `0` |
| `string` | `""` (vazio) |
| `bool` | `false` |
| `pointer`, `interface`, `slice` | `nil` |
| `struct` | `{}` (campos zerados) |

### Tipos Primitivos Comuns

  * `string`
  * `int`, `int8`, `int64`
  * `float32`, `float64`
  * `bool`

### Constantes

Valores imut√°veis, definidos em tempo de compila√ß√£o.

```go
const Pi = 3.14
const Status = "Ativo"
```

-----

## üñ®Ô∏è Output e Input

### Sa√≠da (Output)

  * `fmt.Print`: Imprime sem pular linha.
  * `fmt.Println`: Imprime e pula linha no final.
  * `fmt.Printf`: Imprime formatado.

**Formatadores do Printf:**

  * `%s`: String
  * `%d`: Inteiro (Decimal)
  * `%f`: Float (`%.2f` para 2 casas decimais)
  * `%v`: Valor gen√©rico (serve para qualquer coisa)
  * `%T`: Mostra o Tipo da vari√°vel

### Entrada (Input)

```go
var comando int
// O & indica o endere√ßo de mem√≥ria onde o valor ser√° salvo.
fmt.Scan(&comando)
```

-----

## üîÄ Controle de Fluxo

### IF / ELSE

Sem par√™nteses na condi√ß√£o, chaves `{}` obrigat√≥rias.

```go
if idade >= 18 {
    fmt.Println("Maior de idade")
} else {
    fmt.Println("Menor de idade")
}
```

### Switch

N√£o precisa de `break` (autom√°tico).

```go
switch comando {
    case 1:
        fmt.Println("Monitorando...")
    default:
        fmt.Println("Comando desconhecido")
}
```

### Loops (For)

Go **n√£o** tem `while`. O `for` faz tudo.

```go
// 1. Loop Infinito (While true)
for { }

// 2. Loop Cl√°ssico (C Style)
for i := 0; i < 10; i++ { }

// 3. Range (Python Style)
nomes := []string{"Ana", "Jose"}
for i, nome := range nomes {
    fmt.Println(i, nome)
}
```

-----

## üì¶ Arrays e Slices

### Arrays

Tamanho fixo. Pouco usado.

```go
var sites [4]string
```

### Slices

Tamanho din√¢mico. Muito usado.

```go
nomes := []string{"Douglas", "Daniel"}
nomes = append(nomes, "Novo Nome")

len(nomes) // Tamanho atual
cap(nomes) // Capacidade total alocada
```

> Quando a capacidade estoura, o Go dobra o tamanho do array interno automaticamente.

-----

## ‚öôÔ∏è Funcionalidades de Sistema e Web

### Time / Sleep

Podemos pausar a execu√ß√£o da *goroutine* atual utilizando a fun√ß√£o `Sleep` do pacote `time`.
Isso √© essencial em loops de monitoramento para n√£o sobrecarregar a CPU ou o servi√ßo que est√° sendo consultado, criando um intervalo saud√°vel entre as a√ß√µes.

```go
import "time"

// Pausa a execu√ß√£o por 5 segundos
// time.Second √© uma constante que representa 1 segundo
time.Sleep(5 * time.Second)
```

### Requisi√ß√µes Web (HTTP)

Para fazer chamadas a APIs ou sites externos, usamos o pacote nativo `net/http`.

```go
import ("net/http"; "fmt")

func testaSite(site string) {
    // O _ ignora o erro (n√£o recomendado em prod, mas ok para teste simples)
    resp, _ := http.Get(site)

    if resp.StatusCode == 200 {
        fmt.Println("Site carregado com sucesso!")
    }
}
```

### Sair e Limpar

```go
import ("os"; "os/exec")

// Sai do programa com c√≥digo de sucesso (0) ou erro (-1)
os.Exit(0) 

// Limpar Terminal (Linux/Mac)
func limpar() {
    c := exec.Command("clear")
    c.Stdout = os.Stdout
    c.Run()
}
```

### Defer

Adia a execu√ß√£o de uma fun√ß√£o at√© o momento que a fun√ß√£o pai terminar (return). √â perfeito para garantir o fechamento de recursos.

```go
func ler() {
    arquivo, _ := os.Open("dados.txt")
    defer arquivo.Close() // Ser√° executado por √∫ltimo, n√£o importa o que aconte√ßa
    // ... processamento ...
}
```

-----

## üìÑ Arquivos (Files)

Para ler e escrever arquivos, usamos os pacotes `os` (opera√ß√µes de sistema) e `io` ou `bufio` (leitura).

### Lendo um arquivo inteiro

```go
import ("os"; "fmt")

func lerArquivo() {
    // Retorna um array de bytes (conte√∫do) e um erro
    arquivo, err := os.ReadFile("log.txt") 
    
    if err != nil {
        fmt.Println("Erro ao ler:", err)
    }
    
    // Converte bytes para string
    fmt.Println(string(arquivo)) 
}
```

### Escrevendo em um arquivo

```go
func escreverLog() {
    // Abre o arquivo. Flags: Criar se n√£o existir, Escrita, Append (adicionar no final)
    // 0666 √© a permiss√£o do arquivo no Linux (Leitura/Escrita)
    arquivo, _ := os.OpenFile("log.txt", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
    
    defer arquivo.Close() // Garante o fechamento do arquivo
    
    arquivo.WriteString("Log de erro registrado\n")
}
```

-----

## üèóÔ∏è Orienta√ß√£o a Objetos em Go

Go n√£o tem classes. Go tem **Structs**.

### Structs

√â uma cole√ß√£o de campos. Funciona como o `struct` de C ou objetos literais de JS.

```go
type ContaCorrente struct {
    Titular       string
    NumeroAgencia int
    NumeroConta   int
    Saldo         float64
}

// Instanciando
conta := ContaCorrente{
    Titular:       "Jo√£o Silva",
    NumeroAgencia: 1234,
    Saldo:         1500.75, // Campos omitidos ficam com Valor Zero
}

// Acessando
fmt.Println(conta.Titular)
```

### Ponteiros e Aloca√ß√£o (`new` vs `&`)

Ponteiros armazenam o **endere√ßo de mem√≥ria** de um valor, n√£o o valor em si. Isso economiza mem√≥ria (evita c√≥pias de objetos grandes) e permite alterar o valor original.

**1. Usando `&` (Mais comum):**
Cria a estrutura e retorna o endere√ßo dela.

```go
var conta *ContaCorrente
conta = &ContaCorrente{Titular: "Maria"} 
```

**2. Usando `new`:**
Aloca mem√≥ria zerada e retorna o ponteiro. Pouco usado em estruturas complexas pois n√£o permite inicializar campos na hora.

```go
conta2 := new(ContaCorrente) // Retorna *ContaCorrente
conta2.Titular = "Jos√©"
```

-----

## ‚ö° M√©todos e Fun√ß√µes

### Fun√ß√µes Vari√°dicas

Fun√ß√µes que aceitam um n√∫mero indeterminado de argumentos (usando `...`).

```go
func Somando(numeros ...int) int {
    soma := 0
    for _, num := range numeros {
        soma += num
    }
    return soma
}
// Uso: Somando(1, 2, 3, 4, 5)
```

### M√©todos vs. Fun√ß√µes (Receivers)

Em Go, podemos "anexar" uma fun√ß√£o a uma Struct. Isso √© o equivalente a **M√©todos** em outras linguagens.

**1. Fun√ß√£o Tradicional (Style C):**
Recebe a struct como par√¢metro. N√£o faz parte do objeto.

```go
func sacar(conta *ContaCorrente, valor float64) { ... }
// Uso: sacar(&conta, 200)
```

**2. M√©todo com Receiver (Style Go/POO):**
A fun√ß√£o "pertence" √† struct. O `(c *ContaCorrente)` antes do nome da fun√ß√£o √© o **Receiver**.

```go
func (c *ContaCorrente) Sacar(valor float64) string {
    if c.Saldo >= valor {
        c.Saldo -= valor
        return "Sucesso"
    }
    return "Saldo Insuficiente"
}
// Uso: conta.Sacar(200)
```

> **Dica:** Use **Pointer Receiver** (`*ContaCorrente`) se voc√™ precisa alterar o valor da struct original. Se usar Value Receiver (`ContaCorrente`), voc√™ estar√° mexendo em uma c√≥pia.

-----

## üì¶ Pacotes e Visibilidade

Para organizar o c√≥digo, dividimos em pastas (pacotes).

### Comandos Essenciais

  * `go mod init <nome>`: Cria o m√≥dulo inicial.
  * `go mod tidy`: Baixa depend√™ncias que faltam e remove as que n√£o s√£o usadas (limpeza).
  * `go build ./...`: Compila todos os pacotes dentro da pasta para verificar erros.

### Encapsulamento (Public vs Private)

Go n√£o tem `public` ou `private`. A visibilidade √© definida pela **Letra Inicial**.

  * **Mai√∫scula (ex: `Sacar`)**: **P√∫blico (Exported)**. Vis√≠vel para outros pacotes.
  * **Min√∫scula (ex: `saldo`)**: **Privado (Unexported)**. Vis√≠vel apenas dentro do pacote onde foi criado.

**Exemplo de Encapsulamento (Getters/Setters):**

```go
package contas

type Conta struct {
    Titular string  // P√∫blico
    saldo   float64 // Privado (ningu√©m mexe direto)
}

// M√©todo P√∫blico para ler o saldo privado
func (c *Conta) ObterSaldo() float64 {
    return c.saldo
}
```

-----

## üîÅ Interfaces (Polimorfismo)

Interfaces em Go definem **comportamento**. Se uma struct tem os m√©todos que a interface pede, ela implementa a interface automaticamente (Duck Typing). N√£o existe `implements`.

```go
// Contrato: "Qualquer coisa que tenha o m√©todo VerificarConta √© um Verificavel"
type Verificavel interface {
    VerificarConta() bool
}

func (c ContaCorrente) VerificarConta() bool {
    return true
}

// Esta fun√ß√£o aceita QUALQUER coisa que respeite a interface Verificavel
func RealizarVerificacao(v Verificavel) {
    v.VerificarConta()
}
```